{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PrototypeML Overview Neural network architectures are most often conceptually designed and described in visual terms, but are implemented by writing error-prone code. PrototypeML is a machine learning development environment that bridges the gap between the design and development processes: it provides a highly intuitive visual neural network design interface that supports the full capabilities of the PyTorch deep learning framework, reduces model design and development time, makes debugging easier, and automates many framework and code writing idiosyncrasies. In-depth Read our preprint paper: PrototypeML: A Neural Network Integrated Design and Development Environment","title":"Welcome to PrototypeML"},{"location":"#welcome-to-prototypeml","text":"","title":"Welcome to PrototypeML"},{"location":"#overview","text":"Neural network architectures are most often conceptually designed and described in visual terms, but are implemented by writing error-prone code. PrototypeML is a machine learning development environment that bridges the gap between the design and development processes: it provides a highly intuitive visual neural network design interface that supports the full capabilities of the PyTorch deep learning framework, reduces model design and development time, makes debugging easier, and automates many framework and code writing idiosyncrasies.","title":"Overview"},{"location":"#in-depth","text":"Read our preprint paper: PrototypeML: A Neural Network Integrated Design and Development Environment","title":"In-depth"},{"location":"codegen/","text":"Code generation After you have edited all of the pieces of your project to your satisfaction, you can generate compilable code for the project in one click of your computer mouse. You can then build and run this code on your preferred development machine. Code generation proceeds as follows: A Python class is created for each block PrototypeML concatenates all of the mutator sections (import, init, forward, additional code) from each mutator in each block into a single set of import statements in the class, a single __init__ routine, and a single forward routine. The additional code sections are added to the class after the __init__ and forward routines. Code is generated to implement repeat counts and activations All of the references to magic variables are textually substituted with the actual variables that will contain their values, including parameters, variables, inputs, and outputs, repeat counts, repeat indices, etc. and all references to input and output port values within each block are resolved. This process is analagous to a linker concatenating the program sections from different objects and resolving references.","title":"Code generation"},{"location":"codegen/#code-generation","text":"After you have edited all of the pieces of your project to your satisfaction, you can generate compilable code for the project in one click of your computer mouse. You can then build and run this code on your preferred development machine. Code generation proceeds as follows: A Python class is created for each block PrototypeML concatenates all of the mutator sections (import, init, forward, additional code) from each mutator in each block into a single set of import statements in the class, a single __init__ routine, and a single forward routine. The additional code sections are added to the class after the __init__ and forward routines. Code is generated to implement repeat counts and activations All of the references to magic variables are textually substituted with the actual variables that will contain their values, including parameters, variables, inputs, and outputs, repeat counts, repeat indices, etc. and all references to input and output port values within each block are resolved. This process is analagous to a linker concatenating the program sections from different objects and resolving references.","title":"Code generation"},{"location":"concepts/","text":"Concepts This section introduces the main concepts in PrototypeML: Neural networks as code graphs ; Projects ; Mutators ; Blocks ; Files ; Folders and Code Generation . Representing Neural Network Models as Code Graphs PrototypeML lets you design a neural network by drawing the graph of the network, incorporating already-written components like the PyTorch library and community-contributed components, with (optionally) components you write. Using a drag-and-drop interface, you drag desired components into the editor, then draw arcs using point-and-click to connect an output port of one component to an input port of another, thus showing your desired data flow. Components can be repeated using a repeat count. You can define parameters to customize their behavior, and commonly-used activations can be automatically applied to their outputs. \"Skip connections\" are easily handled just by drawing an arc directly from the input of a graph of components directly to the output. Multiple outputs from different components can be combined automatically at the input to a following component, either by concatenating them (you can specify the order and the concatenation dimension), or by adding them. Components can also be nested: Once you've created a component, you can reuse it within another component. You can write your own components using any programming language you wish. PrototypeML provides specific support for writing your own Python-based components that use PyTorch: You write the init and forward code, and PrototypeML takes care of inserting parameters (if any), and connecting the inputs and outputs of your component to other components in the graph. When you are satisfied with your design, PrototypeML provides one-click code generation that outputs human readable, easily debuggable and maintainable code for your model, on par with neural network libraries, although of course the quality of the code exported largely depends upon the quality of the user-implemented code. Projects Neural network designs are organized into projects. A project contains all of the components needed to build the neural network model, including any external libraries used, along with whatever training data, pre-trained weights, and documentation you provide. To begin using PrototypeML, you first need to create a project . Then you can add components to that project, either components you write, or components that come from another project\u2014which could be another one of your projects, or a project created by someone else. All PrototypeML projects reside in a public project repository. You can search for relevant projects by category (tag), e.g. Computer Vision, Natural Language Processing, etc., or use free-text search. Each project has a Readme file describing the project. Once you find a project you're interested in, you can incorporate components from the current version of that project, or you can specify an earlier version if you wish, or specify a range of versions that are acceptable, using semantic versioning [coming soon]. You can also rate a project, by assigning it a star , giving recognition to the author. Projects (including projects created by others) can be forked , meaning a copy of the entire project is made and the copy is added to your list of projects, where you can modify it. You can choose to fork the current version of the project, or you can specify an earlier version if you wish. The forked version is a snapshot made at the time it was forked; this snapshot is not updated automatically when the original project is changed. You can assign a version number to the current (\"dev\") version of any of your own projects by creating a new release . Once you create a versioned release, that version of your project cannot be changed. While all projects are public and available for anyone else to use, please see the the PrototypeML Terms of Use for the details, there are requirements for using components from other people's projects. Mutators Mutators are the fundamental computational components of the neural network model. Mutators can be defined once, and reused as many times in as many places in your neural network as desired. To make reuse easier, input parameters can be defined, which can be specified differently for each instance (use) of the mutator. The aim of the mutator is to wrap all the code necessary to initialize and execute a specific segment of functionality, such as a PyTorch layer, matrix operation, existing 3rd-party library or any arbitrary Python code using the PyTorch init() and forward() pattern. In your project, you can use mutators that you write, or mutators you obtain from the PrototypeML projects repository . PrototypeML supports creating and editing mutators written in Python, following the coding model required for use with Pytorch, for example, that every mutator contains an init routine and a forward routine. The specifics of how to use PyTorch are beyond the scope of this manual; they can be found in the PyTorch Documentation . You can also write mutators in other programming languages, but PrototypeML does not provide editor support for them other than as text files. Any instance of a mutator can be executed repeatedly just by specifying a repeat count for the mutator instance. The outputs of the mutator instance are fed back in to the inputs, and execution is repeated the specified number of times before allowing execution to continue to a downstream component. In the code graph, a mutator is represented as a rectangle with labeled input ports (inputs) and output ports (outputs). Multiple outputs from upstream components can be combined at the input to a mutator instance, either by concatenating them, or adding them. If they are to be concatenated, the concatenation dimension must be specfied. You can easily apply any commonly-used activation to the output of a mutator instance, as well. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU. The mutator editor is used to create and/or edit a Python/PyTorch mutator. It allows you to specify the imports, init code, forward code, and any additional code you need, as required for using the PyTorch library. Mutators can be written in other languages, but PrototypeML does not provide editor support for them other than as text files. Note that mutators have properties, and mutator instances have a different (in some cases, overriding) set of properties. The mutator is the definition , the mutator instance is the use . Blocks Blocks contain code graphs whose nodes are mutators and/or other blocks. Like mutators, blocks can be defined once, and reused as many times in as many places in your neural network as desired. Blocks can also define input parameters which can be specified differently for each instance (use) of a block. Unlike mutators, blocks can also define input variables, which can be arbitrary Python expressions and can use any of the input parameters defined. Like mutators, any instance of a block can be executed repeatedly just by specifying a repeat count for the block instance. The outputs of the block instance are fed back in to the inputs, and execution is repeated the specified number of times before allowing execution to continue to a downstream component. As with mutators, in the code graph, a block is represented as a rectangle with labeled input ports (inputs) and output ports (outputs). Multiple outputs from upstream components can be combined at the input to a block instance, either by concatenating them, or adding them. If they are to be concatenated, the concatenation dimension must be specfied. Also like mutators, you can easily apply any commonly-used activation to the output of a block instance, as well. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU. The block editor is used to create and/or edit a block. Using a drag-and-drop interface, it allows you to you drag mutators or other blocks into the editor, then draw arcs using point-and-click to connect the outputs of one component to the inputs of another, thus showing your desired data flow. Note that blocks have properties, and block instances have a different (in some cases, overriding) set of properties. The block is the definition , the block instance is the use . Files In addition to mutators and blocks , your project can contain files, including Python (.py), Markdown (.md), and text (.txt) files [coming soon: other types of files]. Any Python files are included with the rest of the generated code when you click the export code button. Mutators can import Python (.py) files contained in the project, using relative imports. Files containing code written in other languages can be made accessible to the project by turning the code into a Python library and then import ing the library. Folders PrototypeML provides you with a virtual directory structure in which to store your components. The root of this virtual directory structure is designated / , and new projects are created with only that folder. You can create as many folders inside / as you wish, and additionally, you can create folders inside folders. Any folder can contain any of the file types PrototypeML supports. Code Generation After you have edited all of the pieces of your project to your satisfaction, you can generate compilable code for the project in one click of your computer mouse. You can then build and run this code on your preferred development machine. Code generation proceeds as follows: A Python class is created for each block PrototypeML concatenates all of the mutator sections (import, init, forward, additional code) from each mutator in each block into a single set of import statements in the class, a single __init__ routine, and a single forward routine. The additional code sections are added to the class after the __init__ and forward routines. Code is generated to implement repeat counts and activations All of the references within the code to properties like parameters, variables, repeat counts, and input & output ports are resolved. This process is analagous to a linker concatenating the program sections from different objects and resolving references.","title":"Concepts"},{"location":"concepts/#concepts","text":"This section introduces the main concepts in PrototypeML: Neural networks as code graphs ; Projects ; Mutators ; Blocks ; Files ; Folders and Code Generation .","title":"Concepts"},{"location":"concepts/#representing-neural-network-models-as-code-graphs","text":"PrototypeML lets you design a neural network by drawing the graph of the network, incorporating already-written components like the PyTorch library and community-contributed components, with (optionally) components you write. Using a drag-and-drop interface, you drag desired components into the editor, then draw arcs using point-and-click to connect an output port of one component to an input port of another, thus showing your desired data flow. Components can be repeated using a repeat count. You can define parameters to customize their behavior, and commonly-used activations can be automatically applied to their outputs. \"Skip connections\" are easily handled just by drawing an arc directly from the input of a graph of components directly to the output. Multiple outputs from different components can be combined automatically at the input to a following component, either by concatenating them (you can specify the order and the concatenation dimension), or by adding them. Components can also be nested: Once you've created a component, you can reuse it within another component. You can write your own components using any programming language you wish. PrototypeML provides specific support for writing your own Python-based components that use PyTorch: You write the init and forward code, and PrototypeML takes care of inserting parameters (if any), and connecting the inputs and outputs of your component to other components in the graph. When you are satisfied with your design, PrototypeML provides one-click code generation that outputs human readable, easily debuggable and maintainable code for your model, on par with neural network libraries, although of course the quality of the code exported largely depends upon the quality of the user-implemented code.","title":"Representing Neural Network Models as Code Graphs"},{"location":"concepts/#projects","text":"Neural network designs are organized into projects. A project contains all of the components needed to build the neural network model, including any external libraries used, along with whatever training data, pre-trained weights, and documentation you provide. To begin using PrototypeML, you first need to create a project . Then you can add components to that project, either components you write, or components that come from another project\u2014which could be another one of your projects, or a project created by someone else. All PrototypeML projects reside in a public project repository. You can search for relevant projects by category (tag), e.g. Computer Vision, Natural Language Processing, etc., or use free-text search. Each project has a Readme file describing the project. Once you find a project you're interested in, you can incorporate components from the current version of that project, or you can specify an earlier version if you wish, or specify a range of versions that are acceptable, using semantic versioning [coming soon]. You can also rate a project, by assigning it a star , giving recognition to the author. Projects (including projects created by others) can be forked , meaning a copy of the entire project is made and the copy is added to your list of projects, where you can modify it. You can choose to fork the current version of the project, or you can specify an earlier version if you wish. The forked version is a snapshot made at the time it was forked; this snapshot is not updated automatically when the original project is changed. You can assign a version number to the current (\"dev\") version of any of your own projects by creating a new release . Once you create a versioned release, that version of your project cannot be changed. While all projects are public and available for anyone else to use, please see the the PrototypeML Terms of Use for the details, there are requirements for using components from other people's projects.","title":"Projects"},{"location":"concepts/#mutators","text":"Mutators are the fundamental computational components of the neural network model. Mutators can be defined once, and reused as many times in as many places in your neural network as desired. To make reuse easier, input parameters can be defined, which can be specified differently for each instance (use) of the mutator. The aim of the mutator is to wrap all the code necessary to initialize and execute a specific segment of functionality, such as a PyTorch layer, matrix operation, existing 3rd-party library or any arbitrary Python code using the PyTorch init() and forward() pattern. In your project, you can use mutators that you write, or mutators you obtain from the PrototypeML projects repository . PrototypeML supports creating and editing mutators written in Python, following the coding model required for use with Pytorch, for example, that every mutator contains an init routine and a forward routine. The specifics of how to use PyTorch are beyond the scope of this manual; they can be found in the PyTorch Documentation . You can also write mutators in other programming languages, but PrototypeML does not provide editor support for them other than as text files. Any instance of a mutator can be executed repeatedly just by specifying a repeat count for the mutator instance. The outputs of the mutator instance are fed back in to the inputs, and execution is repeated the specified number of times before allowing execution to continue to a downstream component. In the code graph, a mutator is represented as a rectangle with labeled input ports (inputs) and output ports (outputs). Multiple outputs from upstream components can be combined at the input to a mutator instance, either by concatenating them, or adding them. If they are to be concatenated, the concatenation dimension must be specfied. You can easily apply any commonly-used activation to the output of a mutator instance, as well. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU. The mutator editor is used to create and/or edit a Python/PyTorch mutator. It allows you to specify the imports, init code, forward code, and any additional code you need, as required for using the PyTorch library. Mutators can be written in other languages, but PrototypeML does not provide editor support for them other than as text files. Note that mutators have properties, and mutator instances have a different (in some cases, overriding) set of properties. The mutator is the definition , the mutator instance is the use .","title":"Mutators"},{"location":"concepts/#blocks","text":"Blocks contain code graphs whose nodes are mutators and/or other blocks. Like mutators, blocks can be defined once, and reused as many times in as many places in your neural network as desired. Blocks can also define input parameters which can be specified differently for each instance (use) of a block. Unlike mutators, blocks can also define input variables, which can be arbitrary Python expressions and can use any of the input parameters defined. Like mutators, any instance of a block can be executed repeatedly just by specifying a repeat count for the block instance. The outputs of the block instance are fed back in to the inputs, and execution is repeated the specified number of times before allowing execution to continue to a downstream component. As with mutators, in the code graph, a block is represented as a rectangle with labeled input ports (inputs) and output ports (outputs). Multiple outputs from upstream components can be combined at the input to a block instance, either by concatenating them, or adding them. If they are to be concatenated, the concatenation dimension must be specfied. Also like mutators, you can easily apply any commonly-used activation to the output of a block instance, as well. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU. The block editor is used to create and/or edit a block. Using a drag-and-drop interface, it allows you to you drag mutators or other blocks into the editor, then draw arcs using point-and-click to connect the outputs of one component to the inputs of another, thus showing your desired data flow. Note that blocks have properties, and block instances have a different (in some cases, overriding) set of properties. The block is the definition , the block instance is the use .","title":"Blocks"},{"location":"concepts/#files","text":"In addition to mutators and blocks , your project can contain files, including Python (.py), Markdown (.md), and text (.txt) files [coming soon: other types of files]. Any Python files are included with the rest of the generated code when you click the export code button. Mutators can import Python (.py) files contained in the project, using relative imports. Files containing code written in other languages can be made accessible to the project by turning the code into a Python library and then import ing the library.","title":"Files"},{"location":"concepts/#folders","text":"PrototypeML provides you with a virtual directory structure in which to store your components. The root of this virtual directory structure is designated / , and new projects are created with only that folder. You can create as many folders inside / as you wish, and additionally, you can create folders inside folders. Any folder can contain any of the file types PrototypeML supports.","title":"Folders"},{"location":"concepts/#code-generation","text":"After you have edited all of the pieces of your project to your satisfaction, you can generate compilable code for the project in one click of your computer mouse. You can then build and run this code on your preferred development machine. Code generation proceeds as follows: A Python class is created for each block PrototypeML concatenates all of the mutator sections (import, init, forward, additional code) from each mutator in each block into a single set of import statements in the class, a single __init__ routine, and a single forward routine. The additional code sections are added to the class after the __init__ and forward routines. Code is generated to implement repeat counts and activations All of the references within the code to properties like parameters, variables, repeat counts, and input & output ports are resolved. This process is analagous to a linker concatenating the program sections from different objects and resolving references.","title":"Code Generation"},{"location":"models/","text":"Editing Models The neural network model editor is the core of PrototypeML. It allows you to design a neural network model by drawing the graph of the network, incorporating already-written components like the PyTorch library and community-contributed blocks , mutators , or other files , with (optionally) components you write. You create blocks using a drag-and-drop interface, you drag desired components into the block editor , then draw arcs using point-and-click to connect the outputs of one component to the inputs of another, thus showing your desired data flow. You create mutators by writing Python PyTorch code using the mutator editor . You can also write code in other languages. When you are satisfied with your model design, PrototypeML provides one-click code generation that outputs human readable, easily debuggable and maintainable code for your model, on par with neural network libraries, although of course the quality of the code exported largely depends upon the quality of the user-implemented code. Important : Changes to components are saved automatically as you type or draw; there is no \"save\" button. Overview of model editor The model editor window has three main sections: the library bar , which lists the components in your model, and allows you to create new components, including adding components from other PrototypeML projects and libraries; the editor window , where you can create and edit blocks, mutators, and other files; and the properties bar, where you can specify various properties of blocks and mutators. Library Bar On the left-hand side of the model editor is the Library Bar, listing the components (blocks, mutators, files, and package dependencies) currently in your project. You can locate files in your project using the search box, or by navigating the folder structure. From the library bar, you can also download all of the code for the current project. Editor Window In the middle of the model editor is the editor window displaying the contents of the current component (block, mutator, or file) being edited. When editing a mutator, the editor window displays the mutator editor . When editing a block, the editor window displays the block editor . When editing a file, the editor window displays the file editor . Across the top of the editor window are tabs showing the names of the components currently being edited. Clicking on a tab opens the component in the editor window, and changes the properties bar contents to display the properties of that component. Properties Bar The properties bar displays various properties of the current block or mutator being edited, and allows you to set or change those properties. Using the Library Bar The library bar is where you can create new mutators, blocks, or files for your project, or incorporate libraries or components from the PrototypeML project repository. It is also the place where you initiate editing any of those components. At the top of the library bar is a search box, where you can search through your components located anywhere in your PrototypeML directory structure. Below the search box is a blue \"Add\" button, which when clicked, brings up a drop-down menu of items you can create or add to your project: block, mutator, folder, file, or package dependency. Next to the \"Add\" button is a black download icon: Click on the icon to download a zip file containing all of the code for your project. Creating components Selecting block, mutator, folder, or file from the \"Add\" menu in the library bar creates that new component in the current directory of your project. A pop-up window requests the name of your new component; enter the desired name, and click \"Ok\" to finish creating the new component. Blocks, mutators, and files can then be edited by clicking on the component in the library bar, which displays the editor for that component. By default, files are created as Python (.py) files. After creating a file, you can change the file type from the properties bar of the file editor. ProtoypeML currently allows file types to be one of (.py, .txt, or .md). Folders can be renamed or removed, as desired, by clicking the 3-dot icon in the folder, which displays a pop-up menu of those choices. Select rename or remove, as desired. Rename displays a pop-up window allowing you to edit the name; click \"Ok\" when done. Remove displays a pop-up window confirming that you really want to remove the folder; click \"Ok\" if you want to remove the folder. Folder removal is irreversible. Adding a package from the projects repository Selecting \"Package Dependency\" from the \"Add\" menu in the library bar allows you to add any project from the projects repository to your project. Unlike when you add a block, mutator, file, or folder, package dependencies are added to a special folder at the root ( / ) of your directory structure, the Packages folder. When you choose to add a package dependency, a pop-up search window appears, allowing you to search the repository using free-text, or by tag, or by choosing a project from the complete list, which is displayed sorted either by most-liked, or by date (newest first). Selecting a package from the list opens a project page for that project, showing the complete list of components, including blocks , mutators , files . Adding components from your package dependencies To insert a component from your package dependencies into a block, first click on the block in the library bar to open up the block editor. Then from the library bar, navigate to the package and then component you'd like to add, and drag it into the code-graph. Connect the input and output ports, specify the properties, and you're done. Organizing your project You can use folders to organize your project. Just as you would for any project, you can keep related files including mutators, blocks, and other files together in a single folder. You can nest folders, as well. Mutator editor To edit a mutator, click on the mutator in the library bar. The code for the mutator will appear in the editor window , and its properties will appear in the properties bar . Program sections of a mutator The mutator editor window is divided into several sections. The imports section is where you write Python import statements for libraries and files (modules) needed by your mutator. The init section is where you write Python code for the init routine of your mutator. The forward section is where you write Python code for the forward routine of your mutator. Finally, the additional code section is where you write other Python code that your mutator will need, if any. Properties of a mutator Mutators have several properties (attributes): name, default repeat count, input and output ports , parameters, and Python package dependencies. The default repeat count specifies the number of times this mutator will be repeated at execution time. The input ports are the input arguments to the mutator. The output ports are the output arguments from the mutator. Parameters are constants that can be defined differently for each use (instance) of the mutator, for example, kernel_size , stride or dilation . You can also define \"select\" parameters (strings) that a user can choose from, e.g. \"left\", \"right\", \"middle\". Default Repeats Repeating a mutator means to take the outputs of the mutator and feed them back into the inputs of the mutator. Not all mutators can be repeated: The mutator has to have the same number of inputs as outputs, and they have to be compatible. The default repeat count specifies the number of times the mutator should be repeated, by default. This default can be overridden when the mutator is used by changing the repeat count property of the mutator instance. Ports The input and output ports of a mutator are the connection between the data flow shown in the code-graph and the actual code. Every mutator needs at least one input port and at least one output port. You can define more than one input or output port. The ports are displayed as large dots on the mutator icon shown in the code graph. By default, the input port is named \"input\" and the output port is named \"output\", but these can be modified by clicking the \"pencil\" icon next to the port and entering a different name in the pop-up form. Additional input and output ports can be added by clicking the \"plus\" icon next to \"Ports\", which will display a pop-up form. Enter the desired name for the new port, specify whether it is an input port or an output port, and click the \"Add Port\" button. Code within a mutator accesses input and output port values using magic variables . Parameters To make reuse of mutators easier, input parameters can be defined, which can be specified differently for each instance (use) of the mutator. Code within a mutator accesses parameter values using magic variables . Parameters can be added by clicking the \"plus\" icon next to \"Parameters\", which will display a pop-up form. There are two kinds of parameters: input (ie. numeric), and select. Enter the desired name for the new parameter, which will help form the identifier used within the code to access the parameter value; the prompt is the string displayed in the properties of any instances of the mutator requesting a value for the parameter; and indicate whether the parameter is required or optional. Next, choose a \"type\" for the parameter. If you choose \"input\" (a numeric type), then specify the default value as any valid Python constant expression. If you choose type \"select\", then the pop-up display changes to allow you to specify the allowed string values for the select. Click the \"plus\" icon next to \"Allowed Values\", and a text box will appear allowing you to enter the name of one of the select options, e.g. \"left\". Click the \"plus\" sign next to \"Allowed Values\" again, and enter another possible select option, e.g. \"right\". Repeat this process until you have specified all of your desired values. To remove a value, click the \"minus\" icon next to the value text box. Regardless of whether you choose a numeric or select parameter type, specify a default value for the parameter, if one. For select parameter types, the default value must be one of the specified select options. Click the \"Add Parameter\" button to create the parameter. Parameters can be edited by clicking the \"pencil\" icon next to the parameter, which will display a pop-up form allowing you to change its attributes. Click \"Update Parameter\" to save the changes. Parameters can be deleted by clicking the \"trash can\" icon next to the parameter name. Python packages Here you can specify any Python packages (dependencies) required by the mutator. PrototypeML will create installation scripts to install those packages on your development machine. Python package dependencies can be added by clicking the \"plus\" icon next to \"Python Packages\", which will display a pop-up form. Specify how the dependency should be installed, ie. via \"pip\", \"conda\", \"conda-forge\", or \"other\". If you choose one of the known package repositories, then you also need to enter the installation string. If you choose \"other\", then you need to enter a download URL for the package. Imports This section is where you write Python import statements for libraries and files (modules) needed by your mutator. If you specify paths in any of the import statements, they should be relative to the project root directory, shown as / in the path shown near the top of the library bar. Standard libraries like PyTorch or NumPy don't need paths, e.g. import PyTorch import NumPy But, for example, if you have a file bluefin.py located in the /tuna subdirectory of your project, and you want to import it, you would write: import tuna/bluefin Init This section is where you write the initialization code for your mutator. To access the values of input and output ports, parameters, the repeat count for the mutator, and the repeat_index (which indicates which iteration of the repeat count you are currently executing), you use magic variables . Magic variables that access the values of parameters are NOT accessible within the forward routine of a mutator, so if you need access to these values within forward , the init routine will need to save them to class variables with instance-unique names. Important : Instance-unique names\u2014Since all of the init sections from all mutators in a block are concatenated into a single __init__ routine in the class of the block containing the mutator, all definitions (and therefore, uses) of constants, variables, and functions within the init routine must be unique to each instance of the mutator. If this is not done, and two mutators try to define the same class variable or function, the later definition will override the first. To avoid this, use the magic variable ${instance} in the name of the variable or function, e.g. self.mutvar_${instance} = 2000 # If this code is contained within a mutator whose *instance name* # (not the name of the mutator itself) is instance_1, # this will generate: self.mutvar_instance_1 = 2000 The instance names of all components within a block must be unique. Magic variables Magic variables provide programmatic access to the inputs, outputs, and parameters of a mutator, and provide an instance-unique name to use to construct identifiers. The actual values for these magic names are textually substituted during code-generation. Here are the available magic variables: ${params} - This is substituted with a comma-separated list of all parameters to a given mutator or block. Usage example: subcall(${params}) # If there are 3 parameters, `param1`, `param2`, and `param3`, # this will generate: subcall(param1, param2, param3) ${params.<name>} - This has the value of parameter with name name . Usage example: if (${params.kernel_size} > 1000): # If kernel_size parameter is set to 2000, this will generate: if (2000 > 1000): ${ports.<name>} - This has the value of the port with name name . Usage example: ${ports.output} = ${ports.input} * ${ports.weights} ${repeat} - This has the value of the repeat count for the mutator or block. Usage example: if (${repeat} > 20): # If repeat count is set to 40, this will generate: if (40 > 20): ${repeat_index} - This has the value of the repeat index for a repeated mutator or block. The repeat index varies from 0 to repeat-1 inclusively. Usage example: if (${repeat_index} == ${repeat}-1): (last loop iteration) ${instance} - This is a unique string generated by PrototypeML for each instance of a mutator. You can use it to construct unique variable names in the init and forward sections of a mutator. Usage example: self.dilation_${instance} = ${params.dilation} # If the dilation parameter is set to 1 for a mutator instance # named \"myconvolv1\", this would generate: self.dilation_myconvolv1 = 1 Forward This section is where you write the code for the PyTorch forward routine for your mutator. To access the values of input and output ports, the repeat count for the mutator, and the repeat_index (which indicates which iteration of the repeat count you are currently executing), you use magic variables . Magic variables that access the values of parameters are NOT accessible within the forward routine of a mutator, so if you need access to these values within forward , the init routine will need to save them to class variables with instance-unique names. Important : Instance-unique names\u2014Since all of the forward sections from all mutators in a block are concatenated into a single forward routine in the class of the block containing the mutator, all definitions (and therefore, uses) of constants, variables, and functions within the forward routine must be unique to each instance of the mutator. If this is not done, and two mutators try to define the same class variable or function, the later definition will override the first. To avoid this, use the magic variable ${instance} in the name of the variable or function, e.g. self.mutvar_${instance} = 2000 # If this code is contained within a mutator whose *instance name* # (not the name of the mutator itself) is instance_1, # this will generate: self.mutvar_instance_1 = 2000 The instance names of all components within a block must be unique. Additional Code This section holds any additional code that can be used in a Python class , for example, functions. The additional code section is inserted after the __init__ and forward routines. The \"Additional Code\" section is inserted into the containing block's class only once, so use of the ${instance} magic variable is not needed. The ${repeat} , and ${repeat_index} magic variables are accessible within the additional code section. Block editor To edit a block, click on the block in the library bar. The code-graph for the block will appear in the editor window , and its properties will appear in the properties bar . From here, you can drag in new components from the library bar and add arcs to connect them to existing components in the code-graph; edit any of the block properties in the properties bar, or by clicking on a component in the code-graph, you can change the properties of that instance of the component in the properties bar. Clicking on an empty area of the code-graph will change the properties bar back to show the block properties instead of the component instance properties. Navigating within the graph (minimap, zoom) Across the top of the editor window are icons that when clicked, let you zoom in or out of the graph; reset the graph view (useful if parts of the graph are out of the window); format the graph, which prettifies the components and arcs; switch to code view, to see the generated code for that block; and turn on or off the \"minimap\" displayed at the upper-right of the code-graph, which shows you which part of the code-graph is visible in the editor window. Adding components to the code-graph There are three steps to add a component to the code-graph: Drag the component from the library bar onto the code-graph Drag arcs from the output(s) of other components to the input of the new component, and likewise, drag arcs from the output(s) of the new component to the input(s) of other components. Set the properties of the new component, including how to combine two or more outputs connected to a single input port, if any Connecting components together (links, input ports, and output ports) Arcs in the code-graph show the data flow between components. To draw an arc connecting a new component, click on the output port of an existing component and hold the mouse down, then drag it to the input port on the new component, and release the mouse. Do the same from the output port of the new component to the input port of an existing component. You are allowed to draw two (or more) arcs to the same input port of some component. In this case, you need to define how the two data streams should be combined. If you click directly on the dot representing the input port, the properties tab of the editor will change to show the properties of that component instance. To delete an arc, select the arc by clicking on it, then either press the Delete key, or, in the properties bar, displayed when you select an arc, click the \"Delete Link\" button. Properties of a block To set the properties of a block, click on the block in the library bar. The properties bar will display the block properties. Block name The name of this block. Default repeat Unless overriden in a block instance, this is the count of the number of times this block will be executed. Not all blocks can be repeated: They have to have the same number of inputs as outputs, and the corresponding inputs and outputs have to be compatible. Ports This section displays the input and output ports for the block. By default, every block has one input port named input and one output port named output . You can add ports by clicking the \"plus\" icon, which will display a pop-up form requesting the name of the port, and whether it is an input or output port. Click \"Add Port\" to finish adding the port. Ports can be renamed (including input and output ), by clicking the \"pencil\" icon next to the port name, and editing the name and/or port type (input vs. output) in the pop-up window. Click \"Update Port\" to save the change. Ports can also be deleted by clicking the \"trash can\" icon next to the port name. Parameters and variables To make reuse of blocks easier, input parameters and variables can be defined, which can be specified differently for each instance (use) of the block. Code within a block accesses parameter and variables values using magic variables . Parameters and variables must have compile-time constant values. Parameters and variables are similar, except that parameter values can only contain constants or constant expressions, whereas variables can contain (constant) expressions that can include parameter values. Parameters can be added by clicking the \"plus\" icon next to \"Parameters\", which will display a pop-up form. There are two kinds of parameters: input (ie. numeric), and select. Enter the desired name for the new parameter, which will help form the identifier used within the code to access the parameter value; the prompt is the string displayed in the properties of any instances of the block requesting a value for the parameter; and indicate whether the parameter is required or optional. Next, choose a \"type\" for the parameter. If you choose \"input\" (a numeric type), then specify the default value as any valid Python constant expression. If you choose type \"select\", then the pop-up display changes to allow you to specify the allowed string values for the select. Click the \"plus\" icon next to \"Allowed Values\", and a text box will appear allowing you to enter the name of one of the select options, e.g. \"left\". Click the \"plus\" sign next to \"Allowed Values\" again, and enter another possible select option, e.g. \"right\". Repeat this process until you have specified all of your desired values. To remove a value, click the \"minus\" icon next to the value text box. Regardless of whether you choose a numeric or select parameter type, specify a default value for the parameter, if one. For select parameter types, the default value must be one of the specified select options. Click the \"Add Parameter\" button to create the parameter. Parameters can be edited by clicking the \"pencil\" icon next to the parameter, which will display a pop-up form allowing you to change its attributes. Click \"Update Parameter\" to save the changes. Parameters can be deleted by clicking the \"trash can\" icon next to the parameter name. Variables are added, edited, and removed in exactly the same way as numeric parameters, except that the definition of a variable can include parameter values. When you are adding a variable, and you click in the definition box, if there are any parameters defined, they will be displayed below the definition box. To insert a parameter value into the expression you are writing in the definition box, just click on the parameter name below the definition box. The definition box accepts any valid Python constant expression. Setting component instance properties Each component instance in the code-graph has a set of properties, some required, some optional. Component instance properties are different from the component properties; they refer to the particular instance of the component in the code-graph. To edit the properties of a block or mutator instance visible in the code-graph window, click on the component instance in the code-graph (not in the library bar), and the properties bar will display the component's properties for you to edit. Instance name The instance name is the name of this particular instance of the block or mutator. Instance names within a block must be unique across all components in the block, regardless of whether they are themselves blocks or mutators. For example, if a block contains two copies of a block or mutator named \"Conv\", then by default, both instances in the graph will initially have instance name \"Conv\"; at least one of them should be renamed, e.g. \"Conv1\". Instance repeats This is the count of the number of times this block or mutator will be executed. Not all blocks and mutators can be repeated: They have to have the same number of inputs as outputs, and the corresponding inputs and outputs have to be compatible. This instance repeat count overrides the default repeat count in the properties of the block or mutator definition. Instance comment This is a place to enter information about what this block or mutator does. Instance activation You can easily apply any commonly-used activation to the output of a block or mutator instance. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU. File editor The file editor is used to edit text files (ie. components that are not blocks or mutators), for example, the Readme file . It is a basic editor showing the lines in the file with line numbers. Move your mouse within the file editor window and click to position the cursor, and use the standard delete and backspace keys for your operating system and device. The properties bar displays the properties of a file, specifically the name and the file type, which can be one of (.py, .md, or .txt). You can modify any of these properties from the properties bar.","title":"Editing Models"},{"location":"models/#editing-models","text":"The neural network model editor is the core of PrototypeML. It allows you to design a neural network model by drawing the graph of the network, incorporating already-written components like the PyTorch library and community-contributed blocks , mutators , or other files , with (optionally) components you write. You create blocks using a drag-and-drop interface, you drag desired components into the block editor , then draw arcs using point-and-click to connect the outputs of one component to the inputs of another, thus showing your desired data flow. You create mutators by writing Python PyTorch code using the mutator editor . You can also write code in other languages. When you are satisfied with your model design, PrototypeML provides one-click code generation that outputs human readable, easily debuggable and maintainable code for your model, on par with neural network libraries, although of course the quality of the code exported largely depends upon the quality of the user-implemented code. Important : Changes to components are saved automatically as you type or draw; there is no \"save\" button.","title":"Editing Models"},{"location":"models/#overview-of-model-editor","text":"The model editor window has three main sections: the library bar , which lists the components in your model, and allows you to create new components, including adding components from other PrototypeML projects and libraries; the editor window , where you can create and edit blocks, mutators, and other files; and the properties bar, where you can specify various properties of blocks and mutators.","title":"Overview of model editor"},{"location":"models/#library-bar","text":"On the left-hand side of the model editor is the Library Bar, listing the components (blocks, mutators, files, and package dependencies) currently in your project. You can locate files in your project using the search box, or by navigating the folder structure. From the library bar, you can also download all of the code for the current project.","title":"Library Bar"},{"location":"models/#editor-window","text":"In the middle of the model editor is the editor window displaying the contents of the current component (block, mutator, or file) being edited. When editing a mutator, the editor window displays the mutator editor . When editing a block, the editor window displays the block editor . When editing a file, the editor window displays the file editor . Across the top of the editor window are tabs showing the names of the components currently being edited. Clicking on a tab opens the component in the editor window, and changes the properties bar contents to display the properties of that component.","title":"Editor Window"},{"location":"models/#properties-bar","text":"The properties bar displays various properties of the current block or mutator being edited, and allows you to set or change those properties.","title":"Properties Bar"},{"location":"models/#using-the-library-bar","text":"The library bar is where you can create new mutators, blocks, or files for your project, or incorporate libraries or components from the PrototypeML project repository. It is also the place where you initiate editing any of those components. At the top of the library bar is a search box, where you can search through your components located anywhere in your PrototypeML directory structure. Below the search box is a blue \"Add\" button, which when clicked, brings up a drop-down menu of items you can create or add to your project: block, mutator, folder, file, or package dependency. Next to the \"Add\" button is a black download icon: Click on the icon to download a zip file containing all of the code for your project.","title":"Using the Library Bar"},{"location":"models/#creating-components","text":"Selecting block, mutator, folder, or file from the \"Add\" menu in the library bar creates that new component in the current directory of your project. A pop-up window requests the name of your new component; enter the desired name, and click \"Ok\" to finish creating the new component. Blocks, mutators, and files can then be edited by clicking on the component in the library bar, which displays the editor for that component. By default, files are created as Python (.py) files. After creating a file, you can change the file type from the properties bar of the file editor. ProtoypeML currently allows file types to be one of (.py, .txt, or .md). Folders can be renamed or removed, as desired, by clicking the 3-dot icon in the folder, which displays a pop-up menu of those choices. Select rename or remove, as desired. Rename displays a pop-up window allowing you to edit the name; click \"Ok\" when done. Remove displays a pop-up window confirming that you really want to remove the folder; click \"Ok\" if you want to remove the folder. Folder removal is irreversible.","title":"Creating components"},{"location":"models/#adding-a-package-from-the-projects-repository","text":"Selecting \"Package Dependency\" from the \"Add\" menu in the library bar allows you to add any project from the projects repository to your project. Unlike when you add a block, mutator, file, or folder, package dependencies are added to a special folder at the root ( / ) of your directory structure, the Packages folder. When you choose to add a package dependency, a pop-up search window appears, allowing you to search the repository using free-text, or by tag, or by choosing a project from the complete list, which is displayed sorted either by most-liked, or by date (newest first). Selecting a package from the list opens a project page for that project, showing the complete list of components, including blocks , mutators , files .","title":"Adding a package from the projects repository"},{"location":"models/#adding-components-from-your-package-dependencies","text":"To insert a component from your package dependencies into a block, first click on the block in the library bar to open up the block editor. Then from the library bar, navigate to the package and then component you'd like to add, and drag it into the code-graph. Connect the input and output ports, specify the properties, and you're done.","title":"Adding components from your package dependencies"},{"location":"models/#organizing-your-project","text":"You can use folders to organize your project. Just as you would for any project, you can keep related files including mutators, blocks, and other files together in a single folder. You can nest folders, as well.","title":"Organizing your project"},{"location":"models/#mutator-editor","text":"To edit a mutator, click on the mutator in the library bar. The code for the mutator will appear in the editor window , and its properties will appear in the properties bar .","title":"Mutator editor"},{"location":"models/#program-sections-of-a-mutator","text":"The mutator editor window is divided into several sections. The imports section is where you write Python import statements for libraries and files (modules) needed by your mutator. The init section is where you write Python code for the init routine of your mutator. The forward section is where you write Python code for the forward routine of your mutator. Finally, the additional code section is where you write other Python code that your mutator will need, if any.","title":"Program sections of a mutator"},{"location":"models/#properties-of-a-mutator","text":"Mutators have several properties (attributes): name, default repeat count, input and output ports , parameters, and Python package dependencies. The default repeat count specifies the number of times this mutator will be repeated at execution time. The input ports are the input arguments to the mutator. The output ports are the output arguments from the mutator. Parameters are constants that can be defined differently for each use (instance) of the mutator, for example, kernel_size , stride or dilation . You can also define \"select\" parameters (strings) that a user can choose from, e.g. \"left\", \"right\", \"middle\".","title":"Properties of a mutator"},{"location":"models/#default-repeats","text":"Repeating a mutator means to take the outputs of the mutator and feed them back into the inputs of the mutator. Not all mutators can be repeated: The mutator has to have the same number of inputs as outputs, and they have to be compatible. The default repeat count specifies the number of times the mutator should be repeated, by default. This default can be overridden when the mutator is used by changing the repeat count property of the mutator instance.","title":"Default Repeats"},{"location":"models/#ports","text":"The input and output ports of a mutator are the connection between the data flow shown in the code-graph and the actual code. Every mutator needs at least one input port and at least one output port. You can define more than one input or output port. The ports are displayed as large dots on the mutator icon shown in the code graph. By default, the input port is named \"input\" and the output port is named \"output\", but these can be modified by clicking the \"pencil\" icon next to the port and entering a different name in the pop-up form. Additional input and output ports can be added by clicking the \"plus\" icon next to \"Ports\", which will display a pop-up form. Enter the desired name for the new port, specify whether it is an input port or an output port, and click the \"Add Port\" button. Code within a mutator accesses input and output port values using magic variables .","title":"Ports"},{"location":"models/#parameters","text":"To make reuse of mutators easier, input parameters can be defined, which can be specified differently for each instance (use) of the mutator. Code within a mutator accesses parameter values using magic variables . Parameters can be added by clicking the \"plus\" icon next to \"Parameters\", which will display a pop-up form. There are two kinds of parameters: input (ie. numeric), and select. Enter the desired name for the new parameter, which will help form the identifier used within the code to access the parameter value; the prompt is the string displayed in the properties of any instances of the mutator requesting a value for the parameter; and indicate whether the parameter is required or optional. Next, choose a \"type\" for the parameter. If you choose \"input\" (a numeric type), then specify the default value as any valid Python constant expression. If you choose type \"select\", then the pop-up display changes to allow you to specify the allowed string values for the select. Click the \"plus\" icon next to \"Allowed Values\", and a text box will appear allowing you to enter the name of one of the select options, e.g. \"left\". Click the \"plus\" sign next to \"Allowed Values\" again, and enter another possible select option, e.g. \"right\". Repeat this process until you have specified all of your desired values. To remove a value, click the \"minus\" icon next to the value text box. Regardless of whether you choose a numeric or select parameter type, specify a default value for the parameter, if one. For select parameter types, the default value must be one of the specified select options. Click the \"Add Parameter\" button to create the parameter. Parameters can be edited by clicking the \"pencil\" icon next to the parameter, which will display a pop-up form allowing you to change its attributes. Click \"Update Parameter\" to save the changes. Parameters can be deleted by clicking the \"trash can\" icon next to the parameter name.","title":"Parameters"},{"location":"models/#python-packages","text":"Here you can specify any Python packages (dependencies) required by the mutator. PrototypeML will create installation scripts to install those packages on your development machine. Python package dependencies can be added by clicking the \"plus\" icon next to \"Python Packages\", which will display a pop-up form. Specify how the dependency should be installed, ie. via \"pip\", \"conda\", \"conda-forge\", or \"other\". If you choose one of the known package repositories, then you also need to enter the installation string. If you choose \"other\", then you need to enter a download URL for the package.","title":"Python packages"},{"location":"models/#imports","text":"This section is where you write Python import statements for libraries and files (modules) needed by your mutator. If you specify paths in any of the import statements, they should be relative to the project root directory, shown as / in the path shown near the top of the library bar. Standard libraries like PyTorch or NumPy don't need paths, e.g. import PyTorch import NumPy But, for example, if you have a file bluefin.py located in the /tuna subdirectory of your project, and you want to import it, you would write: import tuna/bluefin","title":"Imports"},{"location":"models/#init","text":"This section is where you write the initialization code for your mutator. To access the values of input and output ports, parameters, the repeat count for the mutator, and the repeat_index (which indicates which iteration of the repeat count you are currently executing), you use magic variables . Magic variables that access the values of parameters are NOT accessible within the forward routine of a mutator, so if you need access to these values within forward , the init routine will need to save them to class variables with instance-unique names. Important : Instance-unique names\u2014Since all of the init sections from all mutators in a block are concatenated into a single __init__ routine in the class of the block containing the mutator, all definitions (and therefore, uses) of constants, variables, and functions within the init routine must be unique to each instance of the mutator. If this is not done, and two mutators try to define the same class variable or function, the later definition will override the first. To avoid this, use the magic variable ${instance} in the name of the variable or function, e.g. self.mutvar_${instance} = 2000 # If this code is contained within a mutator whose *instance name* # (not the name of the mutator itself) is instance_1, # this will generate: self.mutvar_instance_1 = 2000 The instance names of all components within a block must be unique.","title":"Init"},{"location":"models/#magic-variables","text":"Magic variables provide programmatic access to the inputs, outputs, and parameters of a mutator, and provide an instance-unique name to use to construct identifiers. The actual values for these magic names are textually substituted during code-generation. Here are the available magic variables: ${params} - This is substituted with a comma-separated list of all parameters to a given mutator or block. Usage example: subcall(${params}) # If there are 3 parameters, `param1`, `param2`, and `param3`, # this will generate: subcall(param1, param2, param3) ${params.<name>} - This has the value of parameter with name name . Usage example: if (${params.kernel_size} > 1000): # If kernel_size parameter is set to 2000, this will generate: if (2000 > 1000): ${ports.<name>} - This has the value of the port with name name . Usage example: ${ports.output} = ${ports.input} * ${ports.weights} ${repeat} - This has the value of the repeat count for the mutator or block. Usage example: if (${repeat} > 20): # If repeat count is set to 40, this will generate: if (40 > 20): ${repeat_index} - This has the value of the repeat index for a repeated mutator or block. The repeat index varies from 0 to repeat-1 inclusively. Usage example: if (${repeat_index} == ${repeat}-1): (last loop iteration) ${instance} - This is a unique string generated by PrototypeML for each instance of a mutator. You can use it to construct unique variable names in the init and forward sections of a mutator. Usage example: self.dilation_${instance} = ${params.dilation} # If the dilation parameter is set to 1 for a mutator instance # named \"myconvolv1\", this would generate: self.dilation_myconvolv1 = 1","title":"Magic variables"},{"location":"models/#forward","text":"This section is where you write the code for the PyTorch forward routine for your mutator. To access the values of input and output ports, the repeat count for the mutator, and the repeat_index (which indicates which iteration of the repeat count you are currently executing), you use magic variables . Magic variables that access the values of parameters are NOT accessible within the forward routine of a mutator, so if you need access to these values within forward , the init routine will need to save them to class variables with instance-unique names. Important : Instance-unique names\u2014Since all of the forward sections from all mutators in a block are concatenated into a single forward routine in the class of the block containing the mutator, all definitions (and therefore, uses) of constants, variables, and functions within the forward routine must be unique to each instance of the mutator. If this is not done, and two mutators try to define the same class variable or function, the later definition will override the first. To avoid this, use the magic variable ${instance} in the name of the variable or function, e.g. self.mutvar_${instance} = 2000 # If this code is contained within a mutator whose *instance name* # (not the name of the mutator itself) is instance_1, # this will generate: self.mutvar_instance_1 = 2000 The instance names of all components within a block must be unique.","title":"Forward"},{"location":"models/#additional-code","text":"This section holds any additional code that can be used in a Python class , for example, functions. The additional code section is inserted after the __init__ and forward routines. The \"Additional Code\" section is inserted into the containing block's class only once, so use of the ${instance} magic variable is not needed. The ${repeat} , and ${repeat_index} magic variables are accessible within the additional code section.","title":"Additional Code"},{"location":"models/#block-editor","text":"To edit a block, click on the block in the library bar. The code-graph for the block will appear in the editor window , and its properties will appear in the properties bar . From here, you can drag in new components from the library bar and add arcs to connect them to existing components in the code-graph; edit any of the block properties in the properties bar, or by clicking on a component in the code-graph, you can change the properties of that instance of the component in the properties bar. Clicking on an empty area of the code-graph will change the properties bar back to show the block properties instead of the component instance properties.","title":"Block editor"},{"location":"models/#navigating-within-the-graph-minimap-zoom","text":"Across the top of the editor window are icons that when clicked, let you zoom in or out of the graph; reset the graph view (useful if parts of the graph are out of the window); format the graph, which prettifies the components and arcs; switch to code view, to see the generated code for that block; and turn on or off the \"minimap\" displayed at the upper-right of the code-graph, which shows you which part of the code-graph is visible in the editor window.","title":"Navigating within the graph (minimap, zoom)"},{"location":"models/#adding-components-to-the-code-graph","text":"There are three steps to add a component to the code-graph: Drag the component from the library bar onto the code-graph Drag arcs from the output(s) of other components to the input of the new component, and likewise, drag arcs from the output(s) of the new component to the input(s) of other components. Set the properties of the new component, including how to combine two or more outputs connected to a single input port, if any","title":"Adding components to the code-graph"},{"location":"models/#connecting-components-together-links-input-ports-and-output-ports","text":"Arcs in the code-graph show the data flow between components. To draw an arc connecting a new component, click on the output port of an existing component and hold the mouse down, then drag it to the input port on the new component, and release the mouse. Do the same from the output port of the new component to the input port of an existing component. You are allowed to draw two (or more) arcs to the same input port of some component. In this case, you need to define how the two data streams should be combined. If you click directly on the dot representing the input port, the properties tab of the editor will change to show the properties of that component instance. To delete an arc, select the arc by clicking on it, then either press the Delete key, or, in the properties bar, displayed when you select an arc, click the \"Delete Link\" button.","title":"Connecting components together (links, input ports, and output ports)"},{"location":"models/#properties-of-a-block","text":"To set the properties of a block, click on the block in the library bar. The properties bar will display the block properties.","title":"Properties of a block"},{"location":"models/#block-name","text":"The name of this block.","title":"Block name"},{"location":"models/#default-repeat","text":"Unless overriden in a block instance, this is the count of the number of times this block will be executed. Not all blocks can be repeated: They have to have the same number of inputs as outputs, and the corresponding inputs and outputs have to be compatible.","title":"Default repeat"},{"location":"models/#ports_1","text":"This section displays the input and output ports for the block. By default, every block has one input port named input and one output port named output . You can add ports by clicking the \"plus\" icon, which will display a pop-up form requesting the name of the port, and whether it is an input or output port. Click \"Add Port\" to finish adding the port. Ports can be renamed (including input and output ), by clicking the \"pencil\" icon next to the port name, and editing the name and/or port type (input vs. output) in the pop-up window. Click \"Update Port\" to save the change. Ports can also be deleted by clicking the \"trash can\" icon next to the port name.","title":"Ports"},{"location":"models/#parameters-and-variables","text":"To make reuse of blocks easier, input parameters and variables can be defined, which can be specified differently for each instance (use) of the block. Code within a block accesses parameter and variables values using magic variables . Parameters and variables must have compile-time constant values. Parameters and variables are similar, except that parameter values can only contain constants or constant expressions, whereas variables can contain (constant) expressions that can include parameter values. Parameters can be added by clicking the \"plus\" icon next to \"Parameters\", which will display a pop-up form. There are two kinds of parameters: input (ie. numeric), and select. Enter the desired name for the new parameter, which will help form the identifier used within the code to access the parameter value; the prompt is the string displayed in the properties of any instances of the block requesting a value for the parameter; and indicate whether the parameter is required or optional. Next, choose a \"type\" for the parameter. If you choose \"input\" (a numeric type), then specify the default value as any valid Python constant expression. If you choose type \"select\", then the pop-up display changes to allow you to specify the allowed string values for the select. Click the \"plus\" icon next to \"Allowed Values\", and a text box will appear allowing you to enter the name of one of the select options, e.g. \"left\". Click the \"plus\" sign next to \"Allowed Values\" again, and enter another possible select option, e.g. \"right\". Repeat this process until you have specified all of your desired values. To remove a value, click the \"minus\" icon next to the value text box. Regardless of whether you choose a numeric or select parameter type, specify a default value for the parameter, if one. For select parameter types, the default value must be one of the specified select options. Click the \"Add Parameter\" button to create the parameter. Parameters can be edited by clicking the \"pencil\" icon next to the parameter, which will display a pop-up form allowing you to change its attributes. Click \"Update Parameter\" to save the changes. Parameters can be deleted by clicking the \"trash can\" icon next to the parameter name. Variables are added, edited, and removed in exactly the same way as numeric parameters, except that the definition of a variable can include parameter values. When you are adding a variable, and you click in the definition box, if there are any parameters defined, they will be displayed below the definition box. To insert a parameter value into the expression you are writing in the definition box, just click on the parameter name below the definition box. The definition box accepts any valid Python constant expression.","title":"Parameters and variables"},{"location":"models/#setting-component-instance-properties","text":"Each component instance in the code-graph has a set of properties, some required, some optional. Component instance properties are different from the component properties; they refer to the particular instance of the component in the code-graph. To edit the properties of a block or mutator instance visible in the code-graph window, click on the component instance in the code-graph (not in the library bar), and the properties bar will display the component's properties for you to edit.","title":"Setting component instance properties"},{"location":"models/#instance-name","text":"The instance name is the name of this particular instance of the block or mutator. Instance names within a block must be unique across all components in the block, regardless of whether they are themselves blocks or mutators. For example, if a block contains two copies of a block or mutator named \"Conv\", then by default, both instances in the graph will initially have instance name \"Conv\"; at least one of them should be renamed, e.g. \"Conv1\".","title":"Instance name"},{"location":"models/#instance-repeats","text":"This is the count of the number of times this block or mutator will be executed. Not all blocks and mutators can be repeated: They have to have the same number of inputs as outputs, and the corresponding inputs and outputs have to be compatible. This instance repeat count overrides the default repeat count in the properties of the block or mutator definition.","title":"Instance repeats"},{"location":"models/#instance-comment","text":"This is a place to enter information about what this block or mutator does.","title":"Instance comment"},{"location":"models/#instance-activation","text":"You can easily apply any commonly-used activation to the output of a block or mutator instance. Currently supported activations include: ReLU, Sigmoid, Tanh, Softmax, and Leaky_ReLU.","title":"Instance activation"},{"location":"models/#file-editor","text":"The file editor is used to edit text files (ie. components that are not blocks or mutators), for example, the Readme file . It is a basic editor showing the lines in the file with line numbers. Move your mouse within the file editor window and click to position the cursor, and use the standard delete and backspace keys for your operating system and device. The properties bar displays the properties of a file, specifically the name and the file type, which can be one of (.py, .md, or .txt). You can modify any of these properties from the properties bar.","title":"File editor"},{"location":"projects/","text":"Project management Neural network models are organized into projects. A project contains all of the components needed to build the neural network model, including any external libraries used, along with whatever training data, pre-trained weights, and documentation you provide. From the projects repository page , you can search for projects that interest you, and examine the contents of the project. If you are logged in to your PrototypeML account , you can also create projects , edit project settings , fork a project (make a copy of a project that you can edit), star a project (rate the project), build a project Readme file , tag the project with appropriate categories to make it easier for others to find your work, and finally, you can delete a project you no longer want. Projects Repository Page To reach the projects repository page, click the Projects link from the main menu on the PrototypeML website. On the projects repository page is a sampling of some of the projects that have already been created by people in the PrototypeML community, sorted by popularity (\"Greatest\") by default. You can also sort by \"Latest\" to see the newest projects, using the \"Sort-By\" drop-down menu. If you're logged in to your PrototypeML account, you will also see a \"Show\" drop-down list, where you can select either \"All Projects\" (the default), which displays all projects contributed by the entire PrototypeML community); or \"My Projects\", which displays only your projects. Using the left sidebar on the page, you can search for projects that might interest you, using either free-text search, or by category (tag). To search by free-text, just type the desired search string into the search box, and click the magnifying-glass icon (or hit <Enter>). Free-text search looks for the search string in project names and project descriptions. To search by tag, just click the desired tag. You can specify both a tag and a free-text search string, in which case you will be shown projects that match both criteria, that is, they have been tagged using the specified tag, and they match the search string specified. To clear a search, click on \"All Tags\" and delete the search string from the search box. If you're viewing only your projects, these search tools are used to search only your projects. To search through all projects, select \"All Projects\" from the \"Show\" menu. Project creation To create a new project, click the \"New Project\" button on the projects repository page . You need to specify a name for the project, a description, and one or more tags (categories). These will help other people find your work. Click \"Submit\" to finish creating the project. After the project has been created, PrototypeML displays the project page for your new project. Running across the top are the name of your project; the version number (set to \"Dev\" initially, but you can create a numbered version release later; the number of stars your project has been given by the PrototypeML community (yes, you can star your own project!); the number of times your project has been forked , an \" Edit Model \" button, and drop-down menu of additional operations (marked with a \"gear\" icon) from where you can create a new release , edit your project settings , or delete the project . Below this top line are three or four tabs, one labeled \"Model\" (the default), one labeled \"Releases\", which won't appear until there are versioned releases . The \"Issues\" tab (coming soon) is for users of your project to post problems or questions about your project, and your replies to their posts. The \"Model Weights\" tab (coming soon) is for you to post pre-trained weights, if appropriate, for your network, to allow people to use your project out-of-the box, without training, to apply to some machine learning application. Editing project settings To change the project name, the description, or the tags associated with your project, open the project page for your project, click the \"gear\" icon, and select \"Edit Project Settings\". These are the same settings you had to provide when you first created the project. Forking a project To make a copy of any project (including your own), click the \"Fork\" button on the page for that project. You will be asked to specify a name for that copy (fork) of the project, and it will be added to your list of projects. The forked version is a snapshot made at the time it was forked; this snapshot is not updated automatically when the original project is changed. You can edit this copy of the project. Starring a project You can also rate a project, by assigning it a star , giving recognition to the author. Yes, you can \"star\" your own project! The Readme file The Readme.md file is a Markdown file in which you should put a description of your project, along with instructions on how to use it, and any other information a user of your project would find helpful, including links to relevant material. Creating a release Be default when you create a project, the version number of your project is set to \"Dev\". To allow other people to have a stable version of your project to use, with specific functionality you have defined, you can create a copy of the Dev branch of your project and assign it a version number using semantic versioning [coming soon]. People can then include that specific version of your project in their projects. Creating a versioned copy of a project is called \"creating a release\". The versioned copy cannot be changed. To create a release, find the drop-down menu of additional operations (marked with a \"gear\" icon) on the page for the project you want to release, and select \"Create New Release\". The pop-up form requests a version number, which should conform to the semantic versioning specification. You also need to enter some release notes telling users what is new or changed in this release. Once you create a release, a fourth tab (\"Releases\") will appear on the page for that project, listing all of the releases; clicking on a version number will display the notes for that release. Deleting a project If you want to delete a project you created, find the drop-down menu of additional operations (marked with a \"gear\" icon) on the page for the project you want to delete. Select \"Delete Project\" from the menu. A confirmation box will appear requiring you to verify that you do indeed want to delete the project. Click \"Ok\" to delete the project. Project deletion is irreversible, that is, projects cannot be \"undeleted\", so be sure you really want to delete the project first. Note that deleting a project will not remove it from other projects that have already used it. PrototypeML Accounts You will need to be logged in to your own account on PrototypeML in order to create and manage projects. It is free to create a PrototypeML account. If you do not already have an account on PrototypeML, click on \"Login/Register\" in the main menu on any page, which will display a login form. Click the \"Create a new account\" link below the login form. This will display a registration form, allowing you to register using either your Github login (if you have one), or by specifying new account credentials (username, login email address, and password) directly to PrototypeML. The username is the name that will appear publicly on all of your projects. If you register using Github, your PrototypeML username will be the same as your Github username, and you need to login to PrototypeML using your Github credentials every time you wish to log in. To login to an existing account, click on the \"Login/Register\" button in the main menu on any page, which will display a login form. You may log in using either your Github login (if you used it when you registered), or using your PrototypeML account login email address and password that you specified when you created your PrototypeML account. Fill out the form and click the \"Sign In\" button.","title":"Project management"},{"location":"projects/#project-management","text":"Neural network models are organized into projects. A project contains all of the components needed to build the neural network model, including any external libraries used, along with whatever training data, pre-trained weights, and documentation you provide. From the projects repository page , you can search for projects that interest you, and examine the contents of the project. If you are logged in to your PrototypeML account , you can also create projects , edit project settings , fork a project (make a copy of a project that you can edit), star a project (rate the project), build a project Readme file , tag the project with appropriate categories to make it easier for others to find your work, and finally, you can delete a project you no longer want.","title":"Project management"},{"location":"projects/#projects-repository-page","text":"To reach the projects repository page, click the Projects link from the main menu on the PrototypeML website. On the projects repository page is a sampling of some of the projects that have already been created by people in the PrototypeML community, sorted by popularity (\"Greatest\") by default. You can also sort by \"Latest\" to see the newest projects, using the \"Sort-By\" drop-down menu. If you're logged in to your PrototypeML account, you will also see a \"Show\" drop-down list, where you can select either \"All Projects\" (the default), which displays all projects contributed by the entire PrototypeML community); or \"My Projects\", which displays only your projects. Using the left sidebar on the page, you can search for projects that might interest you, using either free-text search, or by category (tag). To search by free-text, just type the desired search string into the search box, and click the magnifying-glass icon (or hit <Enter>). Free-text search looks for the search string in project names and project descriptions. To search by tag, just click the desired tag. You can specify both a tag and a free-text search string, in which case you will be shown projects that match both criteria, that is, they have been tagged using the specified tag, and they match the search string specified. To clear a search, click on \"All Tags\" and delete the search string from the search box. If you're viewing only your projects, these search tools are used to search only your projects. To search through all projects, select \"All Projects\" from the \"Show\" menu.","title":"Projects Repository Page"},{"location":"projects/#project-creation","text":"To create a new project, click the \"New Project\" button on the projects repository page . You need to specify a name for the project, a description, and one or more tags (categories). These will help other people find your work. Click \"Submit\" to finish creating the project. After the project has been created, PrototypeML displays the project page for your new project. Running across the top are the name of your project; the version number (set to \"Dev\" initially, but you can create a numbered version release later; the number of stars your project has been given by the PrototypeML community (yes, you can star your own project!); the number of times your project has been forked , an \" Edit Model \" button, and drop-down menu of additional operations (marked with a \"gear\" icon) from where you can create a new release , edit your project settings , or delete the project . Below this top line are three or four tabs, one labeled \"Model\" (the default), one labeled \"Releases\", which won't appear until there are versioned releases . The \"Issues\" tab (coming soon) is for users of your project to post problems or questions about your project, and your replies to their posts. The \"Model Weights\" tab (coming soon) is for you to post pre-trained weights, if appropriate, for your network, to allow people to use your project out-of-the box, without training, to apply to some machine learning application.","title":"Project creation"},{"location":"projects/#editing-project-settings","text":"To change the project name, the description, or the tags associated with your project, open the project page for your project, click the \"gear\" icon, and select \"Edit Project Settings\". These are the same settings you had to provide when you first created the project.","title":"Editing project settings"},{"location":"projects/#forking-a-project","text":"To make a copy of any project (including your own), click the \"Fork\" button on the page for that project. You will be asked to specify a name for that copy (fork) of the project, and it will be added to your list of projects. The forked version is a snapshot made at the time it was forked; this snapshot is not updated automatically when the original project is changed. You can edit this copy of the project.","title":"Forking a project"},{"location":"projects/#starring-a-project","text":"You can also rate a project, by assigning it a star , giving recognition to the author. Yes, you can \"star\" your own project!","title":"Starring a project"},{"location":"projects/#the-readme-file","text":"The Readme.md file is a Markdown file in which you should put a description of your project, along with instructions on how to use it, and any other information a user of your project would find helpful, including links to relevant material.","title":"The Readme file"},{"location":"projects/#creating-a-release","text":"Be default when you create a project, the version number of your project is set to \"Dev\". To allow other people to have a stable version of your project to use, with specific functionality you have defined, you can create a copy of the Dev branch of your project and assign it a version number using semantic versioning [coming soon]. People can then include that specific version of your project in their projects. Creating a versioned copy of a project is called \"creating a release\". The versioned copy cannot be changed. To create a release, find the drop-down menu of additional operations (marked with a \"gear\" icon) on the page for the project you want to release, and select \"Create New Release\". The pop-up form requests a version number, which should conform to the semantic versioning specification. You also need to enter some release notes telling users what is new or changed in this release. Once you create a release, a fourth tab (\"Releases\") will appear on the page for that project, listing all of the releases; clicking on a version number will display the notes for that release.","title":"Creating a release"},{"location":"projects/#deleting-a-project","text":"If you want to delete a project you created, find the drop-down menu of additional operations (marked with a \"gear\" icon) on the page for the project you want to delete. Select \"Delete Project\" from the menu. A confirmation box will appear requiring you to verify that you do indeed want to delete the project. Click \"Ok\" to delete the project. Project deletion is irreversible, that is, projects cannot be \"undeleted\", so be sure you really want to delete the project first. Note that deleting a project will not remove it from other projects that have already used it.","title":"Deleting a project"},{"location":"projects/#prototypeml-accounts","text":"You will need to be logged in to your own account on PrototypeML in order to create and manage projects. It is free to create a PrototypeML account. If you do not already have an account on PrototypeML, click on \"Login/Register\" in the main menu on any page, which will display a login form. Click the \"Create a new account\" link below the login form. This will display a registration form, allowing you to register using either your Github login (if you have one), or by specifying new account credentials (username, login email address, and password) directly to PrototypeML. The username is the name that will appear publicly on all of your projects. If you register using Github, your PrototypeML username will be the same as your Github username, and you need to login to PrototypeML using your Github credentials every time you wish to log in. To login to an existing account, click on the \"Login/Register\" button in the main menu on any page, which will display a login form. You may log in using either your Github login (if you used it when you registered), or using your PrototypeML account login email address and password that you specified when you created your PrototypeML account. Fill out the form and click the \"Sign In\" button.","title":"PrototypeML Accounts"}]}